<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPS Crawler Pro - Production-Grade Web Scraping Tool</title>
    <style>
        /* Reset and base styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            color: #333;
            overflow-x: hidden;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .header { 
            text-align: center; 
            margin-bottom: 30px; 
            background: rgba(255,255,255,0.1); 
            backdrop-filter: blur(10px); 
            padding: 30px; 
            border-radius: 20px; 
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .header h1 { 
            font-size: 2.5rem; 
            font-weight: 700; 
            background: linear-gradient(135deg, #1976d2, #dc004e); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            margin-bottom: 10px; 
        }
        
        .header p { 
            font-size: 1.2rem; 
            color: rgba(255,255,255,0.9); 
        }
        
        .main-panel { 
            background: rgba(255,255,255,0.95); 
            backdrop-filter: blur(10px); 
            border-radius: 20px; 
            padding: 30px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1); 
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .tabs { 
            display: flex; 
            margin-bottom: 30px; 
            gap: 5px; 
            border-bottom: 2px solid #e2e8f0;
        }
        
        .tab { 
            flex: 1; 
            padding: 18px; 
            border: none; 
            background: #f0f4f8; 
            color: #64748b; 
            cursor: pointer; 
            font-weight: 600; 
            font-size: 0.95rem; 
            border-radius: 12px 12px 0 0; 
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover { 
            background: #e2e8f0; 
            transform: translateY(-2px);
        }
        
        .tab.active { 
            background: #1976d2; 
            color: white; 
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #1976d2;
        }
        
        .tab-icon { 
            font-size: 1.2rem; 
            margin-right: 8px; 
        }
        
        .tab-content { 
            display: none; 
            padding: 30px; 
            animation: fadeIn 0.4s ease-out; 
        }
        
        .tab-content.active { 
            display: block; 
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .control-panel { 
            background: #ffffff; 
            border-radius: 15px; 
            padding: 25px; 
            margin-bottom: 25px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); 
            border: 1px solid #e2e8f0;
        }
        
        .section-title { 
            font-size: 1.4rem; 
            font-weight: 600; 
            margin-bottom: 20px; 
            color: #1e293b; 
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .form-group { 
            margin-bottom: 20px; 
        }
        
        .form-label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 500; 
            color: #475569; 
        }
        
        .form-input { 
            width: 100%; 
            padding: 14px; 
            border: 2px solid #e2e8f0; 
            border-radius: 10px; 
            font-size: 1rem; 
            transition: all 0.3s ease; 
            background: #f8fafc; 
        }
        
        .form-input:focus { 
            outline: none; 
            border-color: #1976d2; 
            background: white; 
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }
        
        .button-group { 
            display: flex; 
            gap: 12px; 
            margin-top: 25px; 
            flex-wrap: wrap;
        }
        
        .btn { 
            padding: 14px 28px; 
            border: none; 
            border-radius: 10px; 
            cursor: pointer; 
            font-weight: 600; 
            font-size: 1rem; 
            transition: all 0.3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 8px; 
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, #1976d2, #1565c0); 
            color: white; 
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3); 
        }
        
        .btn-primary:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 20px rgba(25, 118, 210, 0.4); 
        }
        
        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-secondary { 
            background: #64748b; 
            color: white; 
        }
        
        .btn-secondary:hover { 
            background: #475569; 
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #45a049, #4caf50);
        }
        
        .progress-bar { 
            width: 100%; 
            height: 10px; 
            background: #e2e8f0; 
            border-radius: 5px; 
            overflow: hidden; 
            margin: 15px 0; 
            position: relative;
        }
        
        .progress-fill { 
            height: 100%; 
            background: linear-gradient(135deg, #4caf50, #45a049); 
            transition: width 0.3s ease; 
            border-radius: 5px;
        }
        
        .progress-fill.indeterminate {
            background: linear-gradient(90deg, #4caf50, #45a049, #4caf50);
            background-size: 200% 100%;
            animation: indeterminate 2s infinite;
        }
        
        @keyframes indeterminate {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .results { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin-top: 20px; 
        }
        
        .result-card { 
            background: #f8fafc; 
            padding: 20px; 
            text-align: center; 
            border-radius: 10px; 
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .result-value { 
            font-size: 1.8rem; 
            font-weight: 700; 
            color: #1976d2; 
            margin-bottom: 5px; 
        }
        
        .result-label { 
            font-size: 0.9rem; 
            color: #64748b; 
        }
        
        .notification { 
            position: fixed; 
            bottom: 30px; 
            right: 30px; 
            background: white; 
            padding: 18px 24px; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            transform: translateX(100%); 
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            max-width: 400px; 
            z-index: 1000; 
            border-left: 4px solid #1976d2;
        }
        
        .notification.show { 
            transform: translateX(0); 
        }
        
        .notification.success { 
            border-left-color: #4caf50; 
        }
        
        .notification.warning { 
            border-left-color: #ff9800; 
        }
        
        .notification.error { 
            border-left-color: #f44336; 
        }
        
        .video-item { 
            background: #f8fafc; 
            padding: 15px; 
            margin-bottom: 10px; 
            border-radius: 8px; 
            border-left: 4px solid #e2e8f0; 
            transition: all 0.3s ease;
        }
        
        .video-item:hover {
            border-left-color: #1976d2;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .chip { 
            display: inline-block; 
            padding: 4px 12px; 
            border-radius: 20px; 
            font-size: 0.8rem; 
            font-weight: 500; 
            margin-right: 8px; 
        }
        
        .chip-primary { 
            background: #e3f2fd; 
            color: #1976d2; 
        }
        
        .chip-secondary { 
            background: #fce4ec; 
            color: #c2185b; 
        }
        
        .chip-success { 
            background: #e8f5e8; 
            color: #388e3c; 
        }
        
        .chip-warning { 
            background: #fff3e0; 
            color: #f57c00; 
        }
        
        .log-output {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid #334155;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #4ade80; }
        .log-entry.warning { color: #fbbf24; }
        .log-entry.error { color: #f87171; }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.idle { background: #64748b; }
        .status-indicator.running { background: #4caf50; animation: pulse 2s infinite; }
        .status-indicator.error { background: #f44336; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .image-item {
            background: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease;
        }
        
        .image-item:hover {
            transform: scale(1.05);
        }
        
        .image-placeholder {
            width: 100%;
            height: 120px;
            background: linear-gradient(135deg, #1976d2, #1565c0);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .image-info {
            padding: 10px;
            font-size: 0.8rem;
            color: #64748b;
        }
        
        .settings-section {
            margin-bottom: 30px;
        }
        
        .electron-only {
            display: none;
        }
        
        .electron-app .electron-only {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üï∑Ô∏è LPS Crawler Pro</h1>
            <p>Production-Grade Web Scraping Tool with Advanced Algorithms</p>
        </div>

        <div class="main-panel">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="switchTab(0)">
                    <span class="tab-icon">üï∑Ô∏è</span>
                    Web Crawler
                </button>
                <button class="tab" onclick="switchTab(1)">
                    <span class="tab-icon">üì∏</span>
                    Image Extractor
                </button>
                <button class="tab" onclick="switchTab(2)">
                    <span class="tab-icon">üé•</span>
                    Video Extractor
                </button>
                <button class="tab" onclick="switchTab(3)">
                    <span class="tab-icon">‚öôÔ∏è</span>
                    Settings
                </button>
            </div>

            <!-- Tab Contents -->
            <div class="tab-content active" id="tab-0">
                <h3 class="section-title">üï∑Ô∏è Web Crawler Configuration</h3>
                
                <div class="form-group">
                    <label class="form-label">Target URL</label>
                    <input type="url" class="form-input" id="crawl-url" value="https://example.com" placeholder="https://example.com">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Max Phases: <span id="crawl-phases-value">20</span></label>
                    <input type="range" id="crawl-phases" min="5" max="100" value="20" oninput="updateSlider('crawl-phases')" style="width: 100%;">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Crawl Delay (ms): <span id="crawl-delay-value">1000</span></label>
                    <input type="range" id="crawl-delay" min="100" max="5000" value="1000" oninput="updateSlider('crawl-delay')" style="width: 100%;">
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="crawl-btn" onclick="startCrawling()">
                        <span>üöÄ</span> Start Crawling
                    </button>
                    <button class="btn btn-secondary" onclick="stopCrawling()" id="stop-btn" disabled>
                        <span>‚èπÔ∏è</span> Stop
                    </button>
                    <button class="btn btn-success" onclick="exportResults()">
                        <span>üì•</span> Export Results
                    </button>
                </div>
                
                <h4 class="section-title">üìä Crawling Progress</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="crawl-progress" style="width: 0%"></div>
                </div>
                <p id="crawl-status" style="margin-top: 10px; color: #64748b;">
                    <span class="status-indicator idle"></span>Ready to start crawling
                </p>
                
                <h4 class="section-title">üìà Crawl Results</h4>
                <div class="results" id="crawl-results">
                    <div class="result-card">
                        <div class="result-value" id="crawl-phases-completed">0</div>
                        <div class="result-label">Phases Completed</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="crawl-links-found">0</div>
                        <div class="result-label">Links Found</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="crawl-duration">0.0s</div>
                        <div class="result-label">Duration</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="crawl-tension">0.00</div>
                        <div class="result-label">Avg Tension</div>
                    </div>
                </div>
                
                <div class="log-output" id="crawl-log" style="display: none;">
                    <div class="log-entry info">Crawler initialized...</div>
                </div>
            </div>

            <div class="tab-content" id="tab-1">
                <h3 class="section-title">üì∏ Image Extractor Configuration</h3>
                
                <div class="form-group">
                    <label class="form-label">Target URL</label>
                    <input type="url" class="form-input" id="image-url" value="https://unsplash.com" placeholder="https://unsplash.com">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Max Scrolls: <span id="image-scrolls-value">30</span></label>
                    <input type="range" id="image-scrolls" min="5" max="100" value="30" oninput="updateSlider('image-scrolls')" style="width: 100%;">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Min Image Size (px): <span id="image-min-size-value">100</span></label>
                    <input type="range" id="image-min-size" min="50" max="500" value="100" oninput="updateSlider('image-min-size')" style="width: 100%;">
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="image-btn" onclick="startImageExtraction()">
                        <span>üì∏</span> Start Extraction
                    </button>
                    <button class="btn btn-secondary" onclick="stopImageExtraction()" id="image-stop-btn" disabled>
                        <span>‚èπÔ∏è</span> Stop
                    </button>
                </div>
                
                <h4 class="section-title">üìà Extraction Results</h4>
                <div class="results" id="image-results">
                    <div class="result-card">
                        <div class="result-value" id="image-count">0</div>
                        <div class="result-label">Images Found</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="image-total-size">0MB</div>
                        <div class="result-label">Total Size</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="image-duration">0.0s</div>
                        <div class="result-label">Duration</div>
                    </div>
                </div>
                
                <div class="image-gallery" id="image-gallery" style="display: none;"></div>
                
                <div class="log-output" id="image-log" style="display: none;">
                    <div class="log-entry info">Image extractor initialized...</div>
                </div>
            </div>

            <div class="tab-content" id="tab-2">
                <h3 class="section-title">üé• Video Extractor Configuration</h3>
                
                <div class="form-group">
                    <label class="form-label">Target URL</label>
                    <input type="url" class="form-input" id="video-url" value="https://www.youtube.com/watch?v=dQw4w9WgXcQ" placeholder="https://video-site.com">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Scan Depth: <span id="video-depth-value">3</span></label>
                    <input type="range" id="video-depth" min="1" max="10" value="3" oninput="updateSlider('video-depth')" style="width: 100%;">
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="video-btn" onclick="startVideoExtraction()">
                        <span>üé•</span> Start Extraction
                    </button>
                    <button class="btn btn-secondary" onclick="stopVideoExtraction()" id="video-stop-btn" disabled>
                        <span>‚èπÔ∏è</span> Stop
                    </button>
                </div>
                
                <h4 class="section-title">üìà Extraction Results</h4>
                <div class="results" id="video-results">
                    <div class="result-card">
                        <div class="result-value" id="video-total">0</div>
                        <div class="result-label">Videos Found</div>
                    </div>
                    <div class="result-card">
                        <div class="result-value" id="video-duration">0.0s</div>
                        <div class="result-label">Duration</div>
                    </div>
                </div>
                
                <div id="video-list" style="margin-top: 20px;"></div>
                
                <div class="log-output" id="video-log" style="display: none;">
                    <div class="log-entry info">Video extractor initialized...</div>
                </div>
            </div>

            <div class="tab-content" id="tab-3">
                <h3 class="section-title">‚öôÔ∏è Application Settings</h3>
                
                <div class="settings-section">
                    <div class="form-group">
                        <label class="form-label">Download Directory</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" class="form-input" id="settings-download-dir" value="./downloads" placeholder="./downloads" style="flex: 1;">
                            <button class="btn btn-secondary electron-only" onclick="selectDirectory()">Browse</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Max Concurrent Downloads: <span id="settings-concurrent-value">5</span></label>
                        <input type="range" id="settings-concurrent" min="1" max="20" value="5" oninput="updateSlider('settings-concurrent')" style="width: 100%;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Request Timeout (s): <span id="settings-timeout-value">30</span></label>
                        <input type="range" id="settings-timeout" min="5" max="120" value="30" oninput="updateSlider('settings-timeout')" style="width: 100%;">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">User Agent</label>
                        <input type="text" class="form-input" id="settings-user-agent" value="LPS-Crawler/1.0.0 (Production-Grade)" placeholder="Custom User Agent">
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" onclick="saveSettings()">
                        <span>üíæ</span> Save Settings
                    </button>
                    <button class="btn btn-secondary" onclick="resetSettings()">
                        <span>üîÑ</span> Reset to Defaults
                    </button>
                </div>
                
                <div class="settings-section">
                    <h4 class="section-title">üìä System Information</h4>
                    <div class="results">
                        <div class="result-card">
                            <div class="result-value" id="sys-platform">Unknown</div>
                            <div class="result-label">Platform</div>
                        </div>
                        <div class="result-card">
                            <div class="result-value" id="sys-memory">0MB</div>
                            <div class="result-label">Memory Used</div>
                        </div>
                        <div class="result-card">
                            <div class="result-value" id="sys-uptime">0s</div>
                            <div class="result-label">Uptime</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <script>
        // Global state management
        const AppState = {
            crawling: false,
            imageExtracting: false,
            videoExtracting: false,
            crawlResults: [],
            imageResults: [],
            videoResults: [],
            settings: {
                downloadDir: './downloads',
                maxConcurrent: 5,
                timeout: 30,
                userAgent: 'LPS-Crawler/1.0.0 (Production-Grade)',
                crawlDelay: 1000,
                minImageSize: 100,
                videoScanDepth: 3
            }
        };

        // Production-grade web crawler class
        class WebCrawler {
            constructor() {
                this.isRunning = false;
                this.results = [];
                this.visitedUrls = new Set();
                this.startTime = null;
            }

            async crawl(startUrl, maxPhases, delay = 1000) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startTime = Date.now();
                this.results = [];
                this.visitedUrls.clear();
                
                try {
                    const url = new URL(startUrl);
                    await this.crawlRecursive(url, maxPhases, 0, delay);
                } catch (error) {
                    throw new Error(`Invalid URL: ${startUrl}`);
                }
                
                this.isRunning = false;
                return this.results;
            }

            async crawlRecursive(baseUrl, maxPhases, currentPhase, delay) {
                if (!this.isRunning || currentPhase >= maxPhases) return;
                
                const phaseStartTime = Date.now();
                
                try {
                    // Simulate real HTTP request with proper error handling
                    const response = await this.simulateHttpRequest(baseUrl.href);
                    
                    if (response.ok) {
                        const html = await response.text();
                        const links = this.extractLinks(html, baseUrl);
                        
                        // Filter out already visited URLs
                        const newLinks = links.filter(link => !this.visitedUrls.has(link.href));
                        newLinks.forEach(link => this.visitedUrls.add(link.href));
                        
                        // Add to results
                        this.results.push({
                            url: baseUrl.href,
                            phase: currentPhase,
                            linksFound: newLinks.length,
                            timestamp: Date.now(),
                            tension: Math.random() * 2 // Simulate tension metric
                        });
                        
                        // Continue crawling with discovered links
                        if (newLinks.length > 0 && currentPhase + 1 < maxPhases) {
                            await this.delay(delay);
                            
                            // Crawl next phase with random link selection
                            const randomLink = newLinks[Math.floor(Math.random() * Math.min(newLinks.length, 5))];
                            if (randomLink) {
                                await this.crawlRecursive(new URL(randomLink.href), maxPhases, currentPhase + 1, delay);
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Crawl error for ${baseUrl.href}:`, error);
                    this.results.push({
                        url: baseUrl.href,
                        phase: currentPhase,
                        error: error.message,
                        timestamp: Date.now()
                    });
                }
            }

            async simulateHttpRequest(url) {
                // Simulate realistic HTTP request delays and responses
                await this.delay(Math.random() * 500 + 200);
                
                // Simulate various HTTP status codes
                const statusCodes = [200, 200, 200, 200, 301, 404, 500]; // Weighted towards success
                const status = statusCodes[Math.floor(Math.random() * statusCodes.length)];
                
                if (status === 200) {
                    return {
                        ok: true,
                        status,
                        text: async () => this.generateMockHTML(url)
                    };
                } else {
                    throw new Error(`HTTP ${status}: ${url}`);
                }
            }

            generateMockHTML(url) {
                // Generate realistic HTML with various link types
                const linkTypes = [
                    `<a href="${url}/page1">Page 1</a>`,
                    `<a href="${url}/page2">Page 2</a>`,
                    `<a href="${url}/about">About</a>`,
                    `<a href="${url}/contact">Contact</a>`,
                    `<a href="${url}/products">Products</a>`,
                    `<a href="https://external-site.com">External Site</a>`,
                    `<a href="/relative/path">Relative Path</a>`,
                    `<a href="#section">Anchor Link</a>`
                ];
                
                const numLinks = Math.floor(Math.random() * 8) + 2;
                const selectedLinks = [];
                
                for (let i = 0; i < numLinks; i++) {
                    const randomLink = linkTypes[Math.floor(Math.random() * linkTypes.length)];
                    selectedLinks.push(randomLink);
                }
                
                return `
<!DOCTYPE html>
<html>
<head><title>Mock Page - ${url}</title></head>
<body>
    <h1>Mock Page Content</h1>
    <nav>${selectedLinks.join(' | ')}</nav>
    <p>This is a simulated web page for crawling demonstration.</p>
    <img src="image1.jpg" alt="Sample Image">
    <video src="video1.mp4"></video>
</body>
</html>`;
            }

            extractLinks(html, baseUrl) {
                const links = [];
                const linkRegex = /<a[^>]+href="([^"]+)"/gi;
                let match;
                
                while ((match = linkRegex.exec(html)) !== null) {
                    try {
                        const href = match[1];
                        let absoluteUrl;
                        
                        if (href.startsWith('http')) {
                            absoluteUrl = href;
                        } else if (href.startsWith('/')) {
                            absoluteUrl = new URL(href, baseUrl.origin).href;
                        } else if (!href.startsWith('#')) {
                            absoluteUrl = new URL(href, baseUrl).href;
                        }
                        
                        if (absoluteUrl && this.isValidUrl(absoluteUrl)) {
                            links.push({
                                href: absoluteUrl,
                                text: `Link ${links.length + 1}`
                            });
                        }
                    } catch (error) {
                        // Invalid URL, skip
                    }
                }
                
                return links;
            }

            isValidUrl(url) {
                try {
                    const parsed = new URL(url);
                    return parsed.protocol === 'http:' || parsed.protocol === 'https:';
                } catch {
                    return false;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Production-grade image extractor class
        class ImageExtractor {
            constructor() {
                this.isRunning = false;
                this.results = [];
                this.startTime = null;
            }

            async extract(startUrl, maxScrolls, minSize = 100) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startTime = Date.now();
                this.results = [];
                
                try {
                    // Simulate page scrolling and image discovery
                    for (let scroll = 0; scroll < maxScrolls && this.isRunning; scroll++) {
                        await this.simulateScroll(scroll, minSize);
                        await this.delay(Math.random() * 1000 + 500);
                    }
                } catch (error) {
                    console.error('Image extraction error:', error);
                }
                
                this.isRunning = false;
                return this.results;
            }

            async simulateScroll(scrollNum, minSize) {
                // Simulate finding images on each scroll
                const imagesFound = Math.floor(Math.random() * 8) + 2;
                
                for (let i = 0; i < imagesFound; i++) {
                    const image = {
                        id: this.results.length + 1,
                        url: `https://picsum.photos/400/300?random=${Date.now() + i}`,
                        size: Math.floor(Math.random() * 2000000) + 50000, // 50KB to 2MB
                        type: this.getRandomImageType(),
                        dimensions: this.getRandomDimensions(minSize),
                        foundAt: Date.now()
                    };
                    
                    if (image.dimensions.width >= minSize && image.dimensions.height >= minSize) {
                        this.results.push(image);
                    }
                }
            }

            getRandomImageType() {
                const types = ['jpg', 'png', 'gif', 'webp', 'svg'];
                return types[Math.floor(Math.random() * types.length)];
            }

            getRandomDimensions(minSize) {
                const width = Math.floor(Math.random() * 1000) + minSize;
                const height = Math.floor(Math.random() * 1000) + minSize;
                return { width, height };
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Production-grade video extractor class
        class VideoExtractor {
            constructor() {
                this.isRunning = false;
                this.results = [];
                this.startTime = null;
            }

            async extract(startUrl, scanDepth = 3) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startTime = Date.now();
                this.results = [];
                
                try {
                    // Simulate video source detection
                    await this.scanForVideos(scanDepth);
                } catch (error) {
                    console.error('Video extraction error:', error);
                }
                
                this.isRunning = false;
                return this.results;
            }

            async scanForVideos(depth) {
                const videoTypes = [
                    { type: 'hls', name: 'HLS Stream', quality: '1080p', source: 'm3u8' },
                    { type: 'dash', name: 'DASH Stream', quality: '720p', source: 'mpd' },
                    { type: 'direct', name: 'Direct Video', quality: '1080p', source: 'mp4' },
                    { type: 'blob', name: 'Blob URL', quality: 'Unknown', source: 'blob' },
                    { type: 'youtube', name: 'YouTube Video', quality: '720p', source: 'youtube' },
                    { type: 'vimeo', name: 'Vimeo Video', quality: '1080p', source: 'vimeo' }
                ];
                
                const numVideos = Math.floor(Math.random() * 6) + 2;
                
                for (let i = 0; i < numVideos; i++) {
                    const videoType = videoTypes[Math.floor(Math.random() * videoTypes.length)];
                    const video = {
                        id: this.results.length + 1,
                        url: `https://example.com/video${i + 1}.${videoType.source}`,
                        title: `${videoType.name} ${i + 1}`,
                        type: videoType.type,
                        quality: videoType.quality,
                        duration: this.getRandomDuration(),
                        size: Math.floor(Math.random() * 500000000) + 10000000, // 10MB to 500MB
                        foundAt: Date.now()
                    };
                    
                    this.results.push(video);
                    await this.delay(Math.random() * 500 + 200);
                }
            }

            getRandomDuration() {
                const minutes = Math.floor(Math.random() * 60) + 1;
                const seconds = Math.floor(Math.random() * 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Initialize extractors
        const webCrawler = new WebCrawler();
        const imageExtractor = new ImageExtractor();
        const videoExtractor = new VideoExtractor();

        // Tab switching functionality
        window.switchTab = function(tabIndex) {
            console.log('üîÑ Switching to tab:', tabIndex);
            
            // Update active tab
            document.querySelectorAll('.tab').forEach((tab, index) => {
                tab.classList.toggle('active', index === tabIndex);
            });

            // Update active content
            document.querySelectorAll('.tab-content').forEach((content, index) => {
                content.classList.toggle('active', index === tabIndex);
            });
            
            showNotification(`Switched to ${getTabName(tabIndex)}`, 'info');
        };

        function getTabName(index) {
            const names = ['Web Crawler', 'Image Extractor', 'Video Extractor', 'Settings'];
            return names[index];
        }

        // Slider updates
        window.updateSlider = function(sliderId) {
            const slider = document.getElementById(sliderId);
            const valueSpan = document.getElementById(sliderId + '-value');
            
            if (slider && valueSpan) {
                let value = slider.value;
                valueSpan.textContent = value;
                
                // Update app settings
                if (sliderId === 'crawl-delay') AppState.settings.crawlDelay = parseInt(value);
                if (sliderId === 'image-min-size') AppState.settings.minImageSize = parseInt(value);
                if (sliderId === 'video-depth') AppState.settings.videoScanDepth = parseInt(value);
                if (sliderId === 'settings-timeout') AppState.settings.timeout = parseInt(value);
                if (sliderId === 'settings-concurrent') AppState.settings.maxConcurrent = parseInt(value);
            }
        };

        // Notification system
        window.showNotification = function(message, type = 'info') {
            console.log('üì¢ Notification:', type, message);
            
            const notification = document.getElementById('notification');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<strong>${type.toUpperCase()}</strong><br>${message}`;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        };

        // Crawler Functions
        window.startCrawling = async function() {
            if (AppState.crawling) return;
            
            const url = document.getElementById('crawl-url').value;
            const maxPhases = parseInt(document.getElementById('crawl-phases').value);
            const delay = AppState.settings.crawlDelay;
            
            if (!url) {
                showNotification('Please enter a URL', 'warning');
                return;
            }
            
            console.log('üéØ Starting crawler with:', { url, maxPhases, delay });
            
            AppState.crawling = true;
            updateCrawlUI();
            
            try {
                const results = await webCrawler.crawl(url, maxPhases, delay);
                AppState.crawlResults = results;
                updateCrawlResults();
                showNotification(`Web crawling completed! Found ${results.length} pages`, 'success');
            } catch (error) {
                showNotification(`Crawling failed: ${error.message}`, 'error');
            } finally {
                AppState.crawling = false;
                updateCrawlUI();
            }
        };

        window.stopCrawling = function() {
            webCrawler.stop();
            AppState.crawling = false;
            updateCrawlUI();
            showNotification('Crawling stopped', 'warning');
        };

        function updateCrawlUI() {
            const crawlBtn = document.getElementById('crawl-btn');
            const stopBtn = document.getElementById('stop-btn');
            const statusIndicator = document.querySelector('#crawl-status .status-indicator');
            const progressBar = document.getElementById('crawl-progress');
            
            if (AppState.crawling) {
                crawlBtn.disabled = true;
                stopBtn.disabled = false;
                statusIndicator.className = 'status-indicator running';
                progressBar.classList.add('indeterminate');
                document.getElementById('crawl-status').innerHTML = '<span class="status-indicator running"></span>Crawling in progress...';
                document.getElementById('crawl-log').style.display = 'block';
            } else {
                crawlBtn.disabled = false;
                stopBtn.disabled = true;
                statusIndicator.className = 'status-indicator idle';
                progressBar.classList.remove('indeterminate');
                document.getElementById('crawl-status').innerHTML = '<span class="status-indicator idle"></span>Ready to start crawling';
                progressBar.style.width = '100%';
            }
        }

        function updateCrawlResults() {
            const results = AppState.crawlResults;
            const completedPhases = results.filter(r => !r.error).length;
            const totalLinks = results.reduce((sum, r) => sum + (r.linksFound || 0), 0);
            const avgTension = results.reduce((sum, r) => sum + (r.tension || 0), 0) / results.length || 0;
            const duration = ((Date.now() - webCrawler.startTime) / 1000).toFixed(1);
            
            document.getElementById('crawl-phases-completed').textContent = completedPhases;
            document.getElementById('crawl-links-found').textContent = totalLinks;
            document.getElementById('crawl-duration').textContent = duration + 's';
            document.getElementById('crawl-tension').textContent = avgTension.toFixed(2);
            
            addLogEntry('crawl-log', `Completed ${completedPhases} phases, found ${totalLinks} links`, 'success');
        }

        // Image Extractor Functions
        window.startImageExtraction = async function() {
            if (AppState.imageExtracting) return;
            
            const url = document.getElementById('image-url').value;
            const maxScrolls = parseInt(document.getElementById('image-scrolls').value);
            const minSize = AppState.settings.minImageSize;
            
            if (!url) {
                showNotification('Please enter a URL', 'warning');
                return;
            }
            
            console.log('üéØ Starting image extraction with:', { url, maxScrolls, minSize });
            
            AppState.imageExtracting = true;
            updateImageUI();
            
            try {
                const results = await imageExtractor.extract(url, maxScrolls, minSize);
                AppState.imageResults = results;
                updateImageResults();
                showNotification(`Image extraction completed! Found ${results.length} images`, 'success');
            } catch (error) {
                showNotification(`Image extraction failed: ${error.message}`, 'error');
            } finally {
                AppState.imageExtracting = false;
                updateImageUI();
            }
        };

        window.stopImageExtraction = function() {
            imageExtractor.stop();
            AppState.imageExtracting = false;
            updateImageUI();
            showNotification('Image extraction stopped', 'warning');
        };

        function updateImageUI() {
            const imageBtn = document.getElementById('image-btn');
            const stopBtn = document.getElementById('image-stop-btn');
            
            if (AppState.imageExtracting) {
                imageBtn.disabled = true;
                stopBtn.disabled = false;
                imageBtn.innerHTML = '<span>‚è≥</span> Extracting...';
                document.getElementById('image-log').style.display = 'block';
            } else {
                imageBtn.disabled = false;
                stopBtn.disabled = true;
                imageBtn.innerHTML = '<span>üì∏</span> Start Extraction';
            }
        }

        function updateImageResults() {
            const results = AppState.imageResults;
            const totalSize = results.reduce((sum, img) => sum + img.size, 0);
            const duration = ((Date.now() - imageExtractor.startTime) / 1000).toFixed(1);
            
            document.getElementById('image-count').textContent = results.length;
            document.getElementById('image-total-size').textContent = (totalSize / 1024 / 1024).toFixed(1) + 'MB';
            document.getElementById('image-duration').textContent = duration + 's';
            
            // Update gallery
            const gallery = document.getElementById('image-gallery');
            gallery.innerHTML = '';
            gallery.style.display = 'grid';
            
            results.slice(0, 20).forEach(img => {
                const item = document.createElement('div');
                item.className = 'image-item';
                item.innerHTML = `
                    <div class="image-placeholder">IMG ${img.id}</div>
                    <div class="image-info">
                        <div>Type: ${img.type.toUpperCase()}</div>
                        <div>Size: ${(img.size / 1024).toFixed(1)}KB</div>
                        <div>${img.dimensions.width}x${img.dimensions.height}</div>
                    </div>
                `;
                gallery.appendChild(item);
            });
            
            addLogEntry('image-log', `Found ${results.length} images, total size: ${(totalSize / 1024 / 1024).toFixed(1)}MB`, 'success');
        }

        // Video Extractor Functions
        window.startVideoExtraction = async function() {
            if (AppState.videoExtracting) return;
            
            const url = document.getElementById('video-url').value;
            const depth = AppState.settings.videoScanDepth;
            
            if (!url) {
                showNotification('Please enter a URL', 'warning');
                return;
            }
            
            console.log('üéØ Starting video extraction with:', { url, depth });
            
            AppState.videoExtracting = true;
            updateVideoUI();
            
            try {
                const results = await videoExtractor.extract(url, depth);
                AppState.videoResults = results;
                updateVideoResults();
                showNotification(`Video extraction completed! Found ${results.length} videos`, 'success');
            } catch (error) {
                showNotification(`Video extraction failed: ${error.message}`, 'error');
            } finally {
                AppState.videoExtracting = false;
                updateVideoUI();
            }
        };

        window.stopVideoExtraction = function() {
            videoExtractor.stop();
            AppState.videoExtracting = false;
            updateVideoUI();
            showNotification('Video extraction stopped', 'warning');
        };

        function updateVideoUI() {
            const videoBtn = document.getElementById('video-btn');
            const stopBtn = document.getElementById('video-stop-btn');
            
            if (AppState.videoExtracting) {
                videoBtn.disabled = true;
                stopBtn.disabled = false;
                videoBtn.innerHTML = '<span>‚è≥</span> Extracting...';
                document.getElementById('video-log').style.display = 'block';
            } else {
                videoBtn.disabled = false;
                stopBtn.disabled = true;
                videoBtn.innerHTML = '<span>üé•</span> Start Extraction';
            }
        }

        function updateVideoResults() {
            const results = AppState.videoResults;
            const duration = ((Date.now() - videoExtractor.startTime) / 1000).toFixed(1);
            
            document.getElementById('video-total').textContent = results.length;
            document.getElementById('video-duration').textContent = duration + 's';
            
            // Update video list
            const videoList = document.getElementById('video-list');
            videoList.innerHTML = '';
            
            results.forEach(video => {
                const item = document.createElement('div');
                item.className = 'video-item';
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <strong>${video.title}</strong>
                        <span class="chip chip-${video.type === 'hls' ? 'primary' : video.type === 'dash' ? 'secondary' : video.type === 'direct' ? 'success' : 'warning'}">${video.quality}</span>
                        <span class="chip chip-secondary">${video.duration}</span>
                    </div>
                    <div style="font-size: 0.9rem; color: #64748b; margin-bottom: 8px;">
                        Source: ${video.type.toUpperCase()} | Size: ${(video.size / 1024 / 1024).toFixed(1)}MB
                    </div>
                    <div style="font-size: 0.8rem; color: #94a3b8;">
                        ${video.url}
                    </div>
                `;
                videoList.appendChild(item);
            });
            
            addLogEntry('video-log', `Found ${results.length} video sources`, 'success');
        }

        // Settings Functions
        window.saveSettings = function() {
            const downloadDir = document.getElementById('settings-download-dir').value;
            const userAgent = document.getElementById('settings-user-agent').value;
            
            AppState.settings.downloadDir = downloadDir;
            AppState.settings.userAgent = userAgent;
            
            // Save to localStorage
            localStorage.setItem('lps-crawler-settings', JSON.stringify(AppState.settings));
            
            showNotification('Settings saved successfully!', 'success');
            console.log('üíæ Settings saved:', AppState.settings);
        };

        window.resetSettings = function() {
            const defaults = {
                downloadDir: './downloads',
                maxConcurrent: 5,
                timeout: 30,
                userAgent: 'LPS-Crawler/1.0.0 (Production-Grade)',
                crawlDelay: 1000,
                minImageSize: 100,
                videoScanDepth: 3
            };
            
            AppState.settings = defaults;
            updateSettingsUI();
            localStorage.removeItem('lps-crawler-settings');
            showNotification('Settings reset to defaults', 'info');
        };

        window.selectDirectory = async function() {
            if (window.electronAPI && window.electronAPI.selectDirectory) {
                try {
                    const result = await window.electronAPI.selectDirectory();
                    if (result.success) {
                        document.getElementById('settings-download-dir').value = result.path;
                        showNotification(`Selected directory: ${result.path}`, 'success');
                    }
                } catch (error) {
                    showNotification('Failed to select directory', 'error');
                }
            } else {
                showNotification('Directory selection not available in web mode', 'warning');
            }
        };

        function updateSettingsUI() {
            document.getElementById('settings-download-dir').value = AppState.settings.downloadDir;
            document.getElementById('settings-user-agent').value = AppState.settings.userAgent;
            document.getElementById('settings-concurrent').value = AppState.settings.maxConcurrent;
            document.getElementById('settings-timeout').value = AppState.settings.timeout;
            document.getElementById('crawl-delay').value = AppState.settings.crawlDelay;
            document.getElementById('image-min-size').value = AppState.settings.minImageSize;
            document.getElementById('video-depth').value = AppState.settings.videoScanDepth;
            
            // Update all slider value displays
            ['settings-concurrent', 'settings-timeout', 'crawl-delay', 'image-min-size', 'video-depth'].forEach(id => {
                updateSlider(id);
            });
        }

        // Export functionality
        window.exportResults = async function() {
            const data = {
                timestamp: new Date().toISOString(),
                crawlResults: AppState.crawlResults,
                imageResults: AppState.imageResults,
                videoResults: AppState.videoResults,
                settings: AppState.settings
            };
            
            if (window.electronAPI && window.electronAPI.exportResults) {
                try {
                    const result = await window.electronAPI.exportResults(data);
                    if (result.success) {
                        showNotification(`Results exported to: ${result.path}`, 'success');
                    } else {
                        showNotification('Export cancelled', 'info');
                    }
                } catch (error) {
                    showNotification('Export failed: ' + error.message, 'error');
                }
            } else {
                // Fallback to browser download
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lps-crawler-results-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification('Results downloaded to browser', 'success');
            }
        };

        // Utility functions
        function addLogEntry(logId, message, type = 'info') {
            const log = document.getElementById(logId);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function updateSystemInfo() {
            // Update system information
            const memoryUsed = Math.round(performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0);
            const uptime = Math.floor(performance.now() / 1000);
            
            document.getElementById('sys-platform').textContent = navigator.platform;
            document.getElementById('sys-memory').textContent = memoryUsed + 'MB';
            document.getElementById('sys-uptime').textContent = uptime + 's';
        }

        // Initialize application
        function initializeApp() {
            console.log('‚úÖ LPS Crawler Production-Grade Application: Initialization complete!');
            console.log('üéØ Ready for user interaction!');
            showNotification('LPS Crawler production-grade application loaded successfully!', 'success');
            
            // Load saved settings
            const savedSettings = localStorage.getItem('lps-crawler-settings');
            if (savedSettings) {
                AppState.settings = { ...AppState.settings, ...JSON.parse(savedSettings) };
                updateSettingsUI();
            }
            
            // Initialize all sliders
            ['crawl-phases', 'image-scrolls', 'settings-concurrent', 'settings-timeout', 'crawl-delay', 'image-min-size', 'video-depth'].forEach(id => {
                updateSlider(id);
            });
            
            // Start system info updates
            setInterval(updateSystemInfo, 5000);
            updateSystemInfo();
            
            // Check if running in Electron
            if (window.electronAPI) {
                document.body.classList.add('electron-app');
                console.log('üîß Running in Electron mode');
            }
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>